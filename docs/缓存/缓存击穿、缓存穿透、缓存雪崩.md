
缓存击穿

  定义：缓存中的key一般设有过期时间，如果某个key过期了，恰在这个时候，有大量的并发请求访问这个key，则这些请求都会到达DB,导致DB瞬间压力过大，压垮DB。
  
  解决方案：

    1.设置互斥锁，mutex。
    
    当缓存失效时不时立即去访问数据库，而是使用缓存工具的操作成功带返回值的操作，比如redis的setnx（set if not exit），memcache的add，利用setnx实现
    
    锁的效果。
    
    缺点：可能造成死锁，或线程池阻塞

    2.提前使用互斥锁
    
    redist的超时时间是timeout1，value的超时时间是timeout2,timeout2 < timeout1。 当timeout2超时时，延长timeout2的时间。并重新设置到redis中。
    
    3.永远不过期
    
    不设置过期时间。
    
    把过期时间设到value里，如果快要过期了，通过一个后台异步线程进行缓存的构建，也就是逻辑过期。

缓存穿透

  定义：查询一个一定不存在的数据。如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

如果对该key的并发访问量过大，则会压垮数据库。

  解决方案：

    1.采用过滤器，把所有数据库中不可能存在的数据hash到一张大的bitmap中，如果key在数据库中不存在，将会被bitmap拦截。
    
    2.对查出为空的key，也在缓存中简历key value对，只是过期时间设的短一点，比如5minetes。

缓存雪崩

  定义：指缓存中大量的数据在同一时间失效，这时有大量的请求会被直接转到数据库，造成数据库的压力过大。
  
  解决方案：
    
    1.加锁，加队列，如mq，保证缓存的单线程写，避免key失效时，大量并发到达数据库。
    
    2.把缓存失效时间错开。比如在原有失效时间上加一个随机值，比如1-5分钟，这样失效时间的重复率降低，降低集体失效的概率。

总结：
  
  缓存雪崩是大量key同时失效事件，而缓存击穿和缓存穿透都是都是单个key失效，大量请求访问该key；不同的是缓存击穿，key对应的value值存在于数据库中，而缓
  
  存穿透的key, value不存在数据库中，可能被用来恶意攻击。
